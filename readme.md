这个任务的核心是：不使用任何现成的网络框架（如Netty），只使用Java最基础的 Socket 编程接口，亲手实现一个简化版的HTTP客户端和服务器，并在此基础上实现用户注册和登录的接口。

你可以把它想象成自己动手造两个“轮子”：

一个迷你版的“浏览器”（HTTP客户端）：它能向服务器发送请求，并能正确接收和显示服务器的回复，特别是能智能地处理重定向。

一个迷你版的“网站服务器”（HTTP服务器）：它能理解并处理来自客户端（包括你的迷你浏览器或Postman）的请求，并返回正确的网页、数据或状态码，同时还要实现“长连接”以提升效率。

下面我们把这个大任务分解成具体的模块和功能点：

第一部分：HTTP客户端
你的客户端程序需要做到以下几点：

发送HTTP请求：

你需要通过Java Socket 连接到服务器。

根据HTTP协议的格式，手动拼接出一个完整的HTTP请求报文。这个报文包括：

请求行：例如 GET /index.html HTTP/1.1

请求头：例如 Host: www.example.com， Connection: keep-alive（为了实现长连接）

空行：用于分隔头部和主体。

请求体：对于POST请求，这里会包含要提交的数据（比如用户名和密码）。

将这个拼接好的字符串通过Socket的输出流发送给服务器。

接收并呈现响应：

通过Socket的输入流读取服务器返回的所有数据。

这些数据是一个HTTP响应报文，你需要对它进行解析。

响应报文也分为：

状态行：例如 HTTP/1.1 200 OK

响应头：包含一些元信息，如 Content-Type（告诉客户端返回的数据是什么类型）、Content-Length（数据长度）、Location（用于重定向）等。

空行

响应体：服务器返回的实际内容，比如HTML页面、图片数据等。

你的程序需要能把这个响应报文清晰地展示给用户，无论是在命令行窗口打印出来，还是在一个简单的图形界面里显示。

特殊处理重定向状态码：

301（永久移动） / 302（临时移动）：当你收到这两个状态码时，响应头里会包含一个 Location 字段，里面指明了新的URL。你的客户端不能简单地显示“已移动”，而应该自动地向这个新的URL发起新的请求。

304（未修改）：这个状态码通常与缓存有关。服务器告诉客户端：“你本地缓存的文件还没过期，可以直接用。” 收到这个状态码时，你的客户端应该从本地缓存中（如果实现了缓存的话）加载资源，而不是认为请求失败。

第二部分：HTTP服务器
你的服务器程序是任务的重点，它需要持续运行，监听端口，并处理多个客户端的请求。

支持GET和POST请求：

你的服务器需要能够解析客户端的请求报文，并判断请求方法是 GET 还是 POST。

GET请求：数据通常附加在URL之后（查询参数），你的服务器需要能从URL中提取这些参数。

POST请求：数据放在请求体中，你的服务器需要正确地从请求体中读取数据（比如表单提交的用户名和密码）。

返回正确的状态码：

200 OK：请求成功。

301/302：重定向。你需要设置 Location 响应头，告诉客户端去新的地址访问。

304 Not Modified：配合 If-Modified-Since 等请求头使用，告知客户端使用缓存。

404 Not Found：请求的资源不存在。

405 Method Not Allowed：客户端使用了服务器不支持的HTTP方法（比如你只实现了GET/POST，但收到了PUT请求）。

500 Internal Server Error：服务器内部处理请求时发生了错误（比如你的代码有Bug抛出了异常）。

实现长连接（HTTP Persistent Connections）：

在HTTP/1.1中，默认是长连接。这意味着在一个TCP连接上，可以连续进行多次请求和响应，而不用每次都重新建立连接。

你的服务器需要在响应头中设置 Connection: keep-alive。

服务器端需要实现逻辑，在一个连接建立后，不是马上关闭它，而是在一段时间内等待同一个客户端的下一个请求，或者处理完一定数量的请求后再关闭。

支持多种MIME类型：

MIME类型告诉浏览器如何处置响应体中的数据。

你的服务器需要能够根据请求文件的扩展名，在响应头中设置正确的 Content-Type。

例如：

.html -> text/html

.css -> text/css

.jpg -> image/jpeg （这就是要求的非文本类型）

.json -> application/json

实现注册和登录功能：

这是业务逻辑部分。

注册：你需要提供一个接口（比如 /register），通过POST请求接收用户名和密码，然后将它们保存在内存中的一个数据结构里（比如一个 HashMap）。不需要存入数据库或文件。

登录：提供一个接口（比如 /login），同样通过POST请求接收用户名和密码，然后与你内存中保存的数据进行比对。如果匹配，则返回成功（如200）；如果不匹配，则返回失败（如401 Unauthorized）。

你可以使用 Postman 这类工具来模拟客户端，向你的服务器发送POST请求，测试注册和登录接口是否正常工作。

总结：你的工作流程
搭建基础框架：分别创建客户端和服务器端的Java项目，建立Socket连接。

实现HTTP协议解析：在客户端和服务器端编写代码，用于按照HTTP协议规范组装和解析报文。

完善服务器功能：先让服务器能处理简单的GET请求（如返回一个静态HTML页面），然后逐步添加POST处理、各种状态码、长连接、MIME类型支持。

实现业务逻辑：在服务器端添加注册和登录的接口处理逻辑。

完善客户端功能：让客户端能发送请求并漂亮地显示响应，特别是实现自动重定向。

测试：用你的客户端测试服务器，同时用Postman测试服务器的注册登录接口。


项目结构：http-socket-project/                 # 项目根文件夹
├── src/                            # 源代码文件夹
│   ├── client/                     # 客户端代码
│   │   ├── HttpClient.java         # 客户端主程序
│   │   ├── RequestBuilder.java     # 构建HTTP请求
│   │   └── ResponseParser.java     # 解析HTTP响应
│   ├── server/                     # 服务器端代码
│   │   ├── HttpServer.java         # 服务器主程序
│   │   ├── RequestHandler.java     # 处理客户端请求
│   │   ├── RequestParser.java      # 解析HTTP请求
│   │   ├── ResponseBuilder.java    # 构建HTTP响应
│   │   └── UserManager.java        # 管理用户注册登录
│   └── shared/                     # 客户端和服务器共享的代码
│       ├── HttpConstants.java      # 定义常量（状态码、MIME类型等）
│       └── HttpUtils.java          # 工具方法
├── webroot/                        # 服务器静态文件目录
│   ├── index.html                  # 首页
│   ├── login.html                  # 登录页面
│   ├── register.html               # 注册页面
│   └── images/                     # 图片文件夹
│       └── example.jpg             # 示例图片
├── lib/                            # 第三方库（这个项目可能不需要）
├── build/                          # 编译后的class文件
├── README.md                       # 项目说明文档
└── run.sh                          # 运行脚本（可选）

## 编译运行
1. 编译所有Java文件：
   ```bash
   javac -d build src/**/*.java# Socket_Homework
